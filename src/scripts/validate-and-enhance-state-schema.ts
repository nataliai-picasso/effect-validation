import * as fs from 'fs';
import * as path from 'path';

interface ProtoStructure {
  hasElementState: boolean;
  hasVisibleState: boolean;
  elementStateFields: string[];
  visibleStateFields: string[];
}

function validateProtoStructure(protoFilePath: string): ProtoStructure {
  const content = fs.readFileSync(protoFilePath, 'utf-8');
  const lines = content.split('\n');
  
  const structure: ProtoStructure = {
    hasElementState: false,
    hasVisibleState: false,
    elementStateFields: [],
    visibleStateFields: []
  };
  
  let currentMessage = '';
  const messageRegex = /^\s*message\s+(\w+)\s*\{/;
  const mapFieldRegex = /^\s*map<[^>]+>\s+(\w+)\s*=/;
  const fieldRegex = /^\s*(?:repeated\s+)?(\w+(?:\.\w+)?)\s+(\w+)\s*=/;
  
  lines.forEach((line) => {
    const messageMatch = line.match(messageRegex);
    if (messageMatch) {
      currentMessage = messageMatch[1];
      if (currentMessage === 'ElementState') structure.hasElementState = true;
      if (currentMessage === 'VisibleState') structure.hasVisibleState = true;
    }
    
    // Check for map fields first
    const mapMatch = line.match(mapFieldRegex);
    if (mapMatch && currentMessage) {
      const fieldName = mapMatch[1];
      
      if (currentMessage === 'ElementState') {
        structure.elementStateFields.push(fieldName);
      } else if (currentMessage === 'VisibleState') {
        structure.visibleStateFields.push(fieldName);
      }
    } else {
      // Check for regular fields
      const fieldMatch = line.match(fieldRegex);
      if (fieldMatch && currentMessage) {
        const fieldType = fieldMatch[1];
        const fieldName = fieldMatch[2];
        
        if (currentMessage === 'ElementState') {
          structure.elementStateFields.push(fieldName);
        } else if (currentMessage === 'VisibleState') {
          structure.visibleStateFields.push(fieldName);
        }
      }
    }
  });
  
  return structure;
}

function validateExpectedStructure(structure: ProtoStructure): void {
  const errors: string[] = [];
  
  if (!structure.hasElementState) {
    errors.push('Missing message ElementState in proto file');
  }
  
  if (!structure.hasVisibleState) {
    errors.push('Missing message VisibleState in proto file');
  }
  
  // Validate ElementState has 'props' field
  if (structure.hasElementState && !structure.elementStateFields.includes('props')) {
    errors.push('ElementState message is missing required "props" field');
  }
  
  if (errors.length > 0) {
    console.error('("Proto structure validation failed:")', '');
    errors.forEach(error => console.error(`  - ${error}`));
    process.exit(1);
  }
  
  console.log('("Proto structure validation passed")', '');
}

function recreateStateSchema(protoFilePath: string, outputSchemaPath: string): void {
  // Verify the proto file exists
  if (!fs.existsSync(protoFilePath)) {
    console.error('("Proto file not found:")', protoFilePath);
    process.exit(1);
  }
  
  // Extract the proto file name for metadata
  const protoFileName = path.basename(protoFilePath);
  
  // Create a new state schema file with custom validation
  const customSchemaContent = `import { Schema } from 'effect';

// Generated schemas for state validation in ${protoFileName}
// Source: ${protoFilePath}
// Generated on: ${new Date().toISOString()}
// 
// This file includes custom validation for states structure where props cannot be empty.
// DO NOT EDIT THIS FILE MANUALLY - it will be regenerated on build.

export const NativeStateTypeSchema = Schema.Literal(
  'UNKNOWN_NativeStateType',
  'hover',
  'focus',
  'disabled',
  'invalid'
);

// Enhanced schema for states structure validation
// This validates the entire states object structure: states.{key}.props cannot be empty
export const StatesSchema = Schema.Record({
  key: Schema.String,
  value: Schema.Struct({
    displayName: Schema.String,
    props: Schema.Record({
      key: Schema.String,
      value: Schema.Unknown
    }).pipe(Schema.filter((record) => Object.keys(record).length > 0, {
      message: () => "props cannot be empty"
    }))
  })
});

export type States = Schema.Schema.Type<typeof StatesSchema>;
export type NativeStateType = Schema.Schema.Type<typeof NativeStateTypeSchema>;
`;
  
  // Write the custom schema file (overwriting the generated one)
  fs.writeFileSync(outputSchemaPath, customSchemaContent, 'utf-8');
  
  console.log('("Recreated schema file with custom validation:")', path.basename(outputSchemaPath));
}

function main(): void {
  const protoDir = path.join(__dirname, '..', 'proto');
  const protoFilePath = path.join(protoDir, 'state.proto');
  const schemaDir = path.join(__dirname, '..', 'proto-based-schemas');
  const schemaFilePath = path.join(schemaDir, 'state.schema.ts');
  
  console.log('("Starting state schema validation and recreation...")', '');
  console.log('("Proto file:")', protoFilePath);
  console.log('("Schema output:")', schemaFilePath);
  
  // Step 1: Validate proto structure
  console.log('("\nStep 1: Validating proto structure...")', '');
  const structure = validateProtoStructure(protoFilePath);
  validateExpectedStructure(structure);
  
  // Step 2: Recreate the state schema with custom validation
  console.log('("\nStep 2: Recreating state.schema.ts with custom validation...")', '');
  recreateStateSchema(protoFilePath, schemaFilePath);
  
  console.log('("\nValidation and schema recreation complete!")', '');
}

// Run the script
main();
