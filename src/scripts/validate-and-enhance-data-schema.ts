import * as fs from 'fs';
import * as path from 'path';

interface ProtoStructure {
  hasDataItem: boolean;
  hasArrayItems: boolean;
  hasDataItems: boolean;
  dataItemFields: string[];
  arrayItemsFields: string[];
  dataItemsFields: string[];
}

function validateProtoStructure(protoFilePath: string): ProtoStructure {
  const content = fs.readFileSync(protoFilePath, 'utf-8');
  const lines = content.split('\n');
  
  const structure: ProtoStructure = {
    hasDataItem: false,
    hasArrayItems: false,
    hasDataItems: false,
    dataItemFields: [],
    arrayItemsFields: [],
    dataItemsFields: []
  };
  
  let currentMessage = '';
  const messageRegex = /^\s*message\s+(\w+)\s*\{/;
  const mapFieldRegex = /^\s*map<[^>]+>\s+(\w+)\s*=/;
  const fieldRegex = /^\s*(?:repeated\s+)?(\w+(?:\.\w+)?)\s+(\w+)\s*=/;
  
  lines.forEach((line) => {
    const messageMatch = line.match(messageRegex);
    if (messageMatch) {
      currentMessage = messageMatch[1];
      if (currentMessage === 'DataItem') structure.hasDataItem = true;
      if (currentMessage === 'ArrayItems') structure.hasArrayItems = true;
      if (currentMessage === 'DataItems') structure.hasDataItems = true;
    }
    
    // Check for map fields first
    const mapMatch = line.match(mapFieldRegex);
    if (mapMatch && currentMessage) {
      const fieldName = mapMatch[1];
      
      if (currentMessage === 'DataItem') {
        structure.dataItemFields.push(fieldName);
      } else if (currentMessage === 'ArrayItems') {
        structure.arrayItemsFields.push(fieldName);
      } else if (currentMessage === 'DataItems') {
        structure.dataItemsFields.push(fieldName);
      }
    } else {
      // Check for regular fields
      const fieldMatch = line.match(fieldRegex);
      if (fieldMatch && currentMessage) {
        const fieldType = fieldMatch[1];
        const fieldName = fieldMatch[2];
        
        if (currentMessage === 'DataItem') {
          structure.dataItemFields.push(fieldName);
        } else if (currentMessage === 'ArrayItems') {
          structure.arrayItemsFields.push(fieldName);
        } else if (currentMessage === 'DataItems') {
          structure.dataItemsFields.push(fieldName);
        }
      }
    }
  });
  
  return structure;
}

function validateExpectedStructure(structure: ProtoStructure): void {
  const errors: string[] = [];
  
  if (!structure.hasDataItem) {
    errors.push('Missing message DataItem in proto file');
  }
  
  if (!structure.hasArrayItems) {
    errors.push('Missing message ArrayItems in proto file');
  }
  
  if (!structure.hasDataItems) {
    errors.push('Missing message DataItems in proto file');
  }
  
  // Validate DataItems has 'items' field
  if (structure.hasDataItems && !structure.dataItemsFields.includes('items')) {
    errors.push('DataItems message is missing required "items" field');
  }
  
  // Validate ArrayItems structure
  if (structure.hasArrayItems) {
    // ArrayItems should have oneof ArrayData with 'data' and 'data_item' fields
    // We check for the presence of these fields indirectly
    const hasExpectedFields = structure.arrayItemsFields.some(field => 
      field === 'data' || field === 'data_item' || field === 'max_size'
    );
    
    if (!hasExpectedFields) {
      errors.push('ArrayItems message structure has changed - expected fields (data, data_item, max_size) not found');
    }
  }
  
  if (errors.length > 0) {
    console.error('("Proto structure validation failed:")', '');
    errors.forEach(error => console.error(`  - ${error}`));
    process.exit(1);
  }
  
  console.log('("Proto structure validation passed")', '');
}

function recreateDataSchema(protoFilePath: string, outputSchemaPath: string): void {
  // Verify the proto file exists
  if (!fs.existsSync(protoFilePath)) {
    console.error('("Proto file not found:")', protoFilePath);
    process.exit(1);
  }
  
  // Extract the proto file name for metadata
  const protoFileName = path.basename(protoFilePath);
  
  // Create a new data schema file with custom validation
  const customSchemaContent = `import { Schema } from 'effect';

// Generated schemas for data validation in ${protoFileName}
// Source: ${protoFilePath}
// Generated on: ${new Date().toISOString()}
// 
// This file includes custom validation for data structure where arrayItems.data.items cannot be empty.
// DO NOT EDIT THIS FILE MANUALLY - it will be regenerated on build.

// Enhanced schema for data structure validation
// This validates the entire data object structure: data.{key}.arrayItems.data.items cannot be empty
export const DataSchema = Schema.Record({
  key: Schema.String,
  value: Schema.Struct({
    arrayItems: Schema.optional(Schema.Struct({
      data: Schema.optional(Schema.Struct({
        items: Schema.Record({
          key: Schema.String,
          value: Schema.Unknown
        }).pipe(Schema.filter((record) => Object.keys(record).length > 0, {
          message: () => "arrayItems.data.items cannot be empty"
        }))
      }))
    }))
  })
});

export type Data = Schema.Schema.Type<typeof DataSchema>;
`;
  
  // Write the custom schema file (overwriting the generated one)
  fs.writeFileSync(outputSchemaPath, customSchemaContent, 'utf-8');
  
  console.log('("Recreated schema file with custom validation:")', path.basename(outputSchemaPath));
}

function main(): void {
  const protoDir = path.join(__dirname, '..', 'proto');
  const protoFilePath = path.join(protoDir, 'data.proto');
  const schemaDir = path.join(__dirname, '..', 'proto-based-schemas');
  const schemaFilePath = path.join(schemaDir, 'data.schema.ts');
  
  console.log('("Starting data schema validation and recreation...")', '');
  console.log('("Proto file:")', protoFilePath);
  console.log('("Schema output:")', schemaFilePath);
  
  // Step 1: Validate proto structure
  console.log('("\nStep 1: Validating proto structure...")', '');
  const structure = validateProtoStructure(protoFilePath);
  validateExpectedStructure(structure);
  
  // Step 2: Recreate the data schema with custom validation
  console.log('("\nStep 2: Recreating data.schema.ts with custom validation...")', '');
  recreateDataSchema(protoFilePath, schemaFilePath);
  
  console.log('("\nValidation and schema recreation complete!")', '');
}

// Run the script
main();
